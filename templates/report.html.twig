{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
<div class="index center">
<h1 id="kmom01">Kmom01</h1></a>
<p class="report">Jag känner till objektorientering från självstudier innan jag började på webbprogrammeringsutbildningen. Här under utbildningen så har jag och min kursare stött på objektorientering
    litet under JavaScript-kursen och mer under OOP-kursen. Vi gick inte in i djupet på vad det är. Det finns en del koncept som (mig veterligen) inte fungerar så bra i Python och som ändå finns i 
    språk som är baserade på OOP. Private/public/protected finns inte på samma sätt i Python. Arv är också mindre utförligt i Python än vad det är i exempelvis C#.
</p>
<p class="report">Mig veterligen så är PHP:s modell för klasser och objekt väldigt likt andra språkers modeller. Jag har inte djupdykt i de andra språken och inte heller i PHP under detta kmom. Men de typiska mönstrena finns här med:
    <ul class="ul-report">
        <li>Arv.</li>
        <li>Konstruktor/destruktor.</li>
        <li>Attribut.</li>
        <li>Objekt.</li>
        <li>Statiska variabler/konstanter.</li>
        <li>Protected/private/public metoder och attribut. Normalfallet är att dessa ska vara private.</li>
    </ul>
</p>

<p class="report">Min uppfattning om kodbasen/koden är att vi använder oss av MVC-designmönstret, med fokus på view och controller. Hittills finns det en del okända delar som jag inte är helt bekant med och
    det sker saker på ett magiskt sett. Det här med att samla routes i olika controllers är jag inte van med. Vi har även flera mappar som heter controllers (i assets och i src). Jag förstår inte heller
    hur encore fungerar än och jag är förvirrad över var bilderna ska placeras. Alla dessa saker skulle jag kunna ta mig tiden till att efterforska redan nu men min erfarenhet med tidigare kurser är 
    att man fattar det till slut ändå. Det är bra att ha frågorna i bakhuvudet i alla fall, då kommer man undermedvetet söka efter svaren. I övrigt så har vi arbetat med MVC-mönstret innan i flera kurser
     men kanske inte så djupt och medvetet som vi kommer arbeta med det nu.
</p>

<p class="report">De områden från <a href="https://phptherightway.com/">PHP The Right Way</a> jag först och främst hade velat lära mig mer om är Servers and Deployment samt Virtualization. Dessa områden är viktiga när man kan grunderna och vill
    skapa en webbapplikation. Jag hade gärna också velat lära mig mer om felhantering (Errors and Exceptions), det känns som att det alltid är bra att kunna detta när man skapar kod för andras skull. 
    Testing är ett område som vi kommer kolla på senare, det är också användbart. Design Patterns är ett intressant område, jag gillar när man pratar om koncept på ett generaliserat plan som går 
att använda på andra områden.</p>

<p class="report">Mina TIL för detta KMOM är:
    <ul class="ul-report">
        <li>Symfony är ett ramverk som Django/Flask/Express för att skapa webbapplikationer i PHP.</li>
        <li>Det går att lägga routes i flera olika filer. Symfony känner igen dessa.</li>
        <li>Även PHP kan skrivas objektorienterat.</li>
        <li>MVC-mönstret verkar vara det bästa mönstret för att samordna koden i en webbapplikation.</li>
        <li>Det är inte helt lätt att få Boostrap att fungera i Symfony 7.</li>
        <li>Har lärt mig mer om MD-filer och hur man skriver en README-fil till sin <a href="https://github.com/airhelios/mvc">Github-repo</a>.</li>
    </ul>

</p>

<h1 id="kmom02">Kmom02</h1></a>

<p class="report">Arv är ett sätt för en klass att ärva attribut och metoder från en annan klass: 
    klasserna får en liknande struktur. Dock kan den ärvande klassen ha fler metoder/attribut än de ärvda.<br>
Komposition är en typ av ägande där en klass äger den andra. När den ägande klassen slutar existera så slutar även den ägda klassen göra det. Den ägda klassen får bara ha en ägare.
<br>Interface är en typ av kontrakt, klassen som implementerar ett interface förbinder sig att ha metoderna i interfacet. Det hindrar dock inte
klassen från att ha fler metoder.<br>
Vissa språk har inte multipelt arv (man kan inte ärva från flera klasser). PHP (och vissa andra språk) kompenserar för detta genom att ha trait istället. 
Trait är en typ av boiler plate-kod med metoder som kan lyftas in i en klass. En klass kan ha flera 
<a href="https://dbwebb.se/guide/kom-igang-med-objektorienterad-programmering-i-php/vad-ar-trait">olika traits</a>. 
<a href="https://www.php.net/manual/en/language.oop5.traits.php">Trait är ingen klass och går inte att instansiera.</a><br>
PHP har i sina tidigare versioner inte kunnat skrivas objekt-orienterat, det var ett procedurellt språk. Objektorientering är inte ett måste för att kunna programmera PHP.
</p>

<p class="report">Jag började den här uppgiften med att göra övningen. Den var för ett tärningsspel och hade sina egna funktioner. 
    Övningen hade också en del funktioner som inte behövdes till det här kursmomentet. Jag skrev om variabelnamn, klassnamn, attribut och metoder för att de skulle passa kursmomentet.
    Jag började som jag oftast gör, med att implementera den klassen som kommer ägas/ärvas (Card). Därefter fokuserade jag på den grafiska representationen (CardGraphic). Jag skapade en CardHand, som egentligen bara är en kopia av
    DiceHand från övningen. Den används inte i det här kursmomentet. Till slut byggde jag DeckOfCards.
    Jag ser en hel del förbättringspotential i form av interface, onödiga klasser/variabler, statiska variabler etc. Jag vet om att jag har en del artefakter kvar i form av variabler och kod som inte används. De kommer från att jag kopierade övningarna och även 
    att jag trodde att jag skulle behöva dem. Jag är dock nöjd med uppgiften. Jag vill inte överarbeta om vi blir tvungna att ändra riktning sen.
</p>

<p class="report">Symfony har sina egenheter, man hjälps en del på traven med funktionerna men man blir också låst. Jag tänker exempelvis på att skriva PHP-logik i Twig. 
    Man får använda inbyggda funktioner istället för att direkt skriva PHP. Jag ser ändå stora fördelar med ramverket. Att skriva det här kursmomentet utan Symfony hade nog gått, det hade dock tagit så mycket längre tid.
    Sessionshanteringen hade varit jobbigare, att göra sidorna hade varit jobbiga, jag hade haft stora problem med att göra routes också. Symfony är inte lika behändigt som Flask dock,
det känns mindre strukturerat. Jag vet inte varför det finns controllers i både assets och i src exempelvis. Var bilderna ska läggas är också lite tvetydigt.</p>   
</p>

<p class="report">Jag har lärt mig mer om OOP i PHP i den här uppgiften (att det är fullt möjligt att skriva OOP i PHP, 
    även om det har några få begränsningar). Jag har lärt mig mer om ordet "dependency injection" (objekt som behövs i klassen injiceras utifrån). 
    Traits var helt nytt för mig. Interface har jag sett innan men jag har nog glömt vad tanken var med det. Jag lärde mig om hur man använder session med Symfony.
    I och med att jag skrev av övningarna istället för att rakt av kopiera dem från exempel-mappen så lärde jag mig mer om hur Symfony fungerar och hur projektet ska byggas upp. 
</p>


<h1 id="kmom03">Kmom03</h1></a>

<p class="report">Jag tyckte att pseudokods-biten inte gav mig något speciellt. Jag ser faktiskt inte nyttan med pseudokod, än. 
    Flödesschemat fungerade bra för att ge mig en grundläggande struktur innan jag började med koden. 
    Dock så slutade jag tänka på den ganska snabbt. Jag gjorde "lokala" flödesscheman när jag behövde. 
    Jag kan nog tänka mig att använda just flödesscheman i framtiden vid behov. Men det blir inga strukturerade utan mest som skisser i mitt anteckningsblock.
</p>

<p class="report">Jag skapade en huvudklass "GameManager" som användes för att hålla koll på kortlek, spelarens hand, dealerns hand och spellogiken. 
    Jag kopierade klasserna från kmom02 (deck) för att jag ville testa nya koncept (dependency injection och interface-klasser). Jag insåg sen att man skulle begränsa koden i sin controller, vilket innebar att jag tog bort dependency injection-aspekten.
    Jag skapade dock en statisk metod som injicerade kortlek, spelarens hand och dealerns hand i konstruktorn för GameManager. Den svåraste biten var nog spellogiken och hur man skulle tänka kring essen.<br><br>
    Jag ser en del förbättringspotential, jag tror exempelvis att spellogiken inte är helt korrekt, jag ser också att min applikation hänger sig då och då men jag vet inte varför. 
    Jag hade också kunnat ta bort en del av logiken från mina twig-mallar samt lägga om en del metoder på Deck/Card/Hand istället för att ha dem i GameManager. Gränssnittet är också en faktor som jag hade velat ändra på.
    <br>Angående lintingen så satte jag phpstan på level 6, jag tyckte det var good enough.
</p>

<p class="report">Jag är ganska nöjd med Symfony, men lämnas småförvirrad ibland. En sak som oroar mig är att det kan dyka upp fel som är svåra att felsöka om det visar sig att dokumentationen för Symfony inte är så omfattande. 
    Jag vill egentligen att det ska finnas många användare av ett ramverk för enklare felsökning. Jag börjar hitta bättre i Symfony nu än tidigare och jag känner mig relativt bekväm med att arbeta i min applikation. Jag hade dock förmodligen blivit tvungen att använda mos dokumentation 
    ifall jag skulle starta ett projekt från scratch.

</p>   


<p class="report">Jag har lärt mig mer om linting samt om statiska analysverktyg. Man kan välja att linta/kontrollera sin kod i olika nivåer. Vi har gått igenom hur man kan strukturera upp sin kod i förväg med exempelvis ramverk(SOLID), pseudokod och flödescheman. 
    Jag har testat att använda dependency inversion principle och interfaces. Jag har lärt mig om hur man kallar en funktion från föräldern i den ärvande klassen samt om hur man skapar statiska metoder. Vi gick igenom lite design patterns också, något som jag tänker att det hade varit kul
    att fördjupa sig i.
</p>

<h1 id="kmom04">Kmom04</h1></a>

<p class="report">Det finns både nackdelar och fördelar med PHPUnit jämfört med exempelvis Pythons enhetstestmodul. Jag upplever att mockningen är mycket enklare i PHPUnit medan det är svårare att testa funktioner som är baserade på
    "random"-modulen. Jag tyckte att PHPUnit var väldigt intuitivt och jag tror det är på grund av att vi skapade en del tester i OOP-kursen.</p>

    <p class="report">Jag lyckades få 100% kodtäckning på min <code>Game-klass</code>. Det var inte särskilt svårt men det tog ganska lång tid. Jag gick bara igenom metod för metod och la till mockning när det behövdes. Jag är dock inte helt säker på
    att jag testar rätt saker och att jag gör det tillräckligt utförligt.</p>
    
    <p class="report">Det fanns en del metoder som inte returnerade något, vilket gjorde det svårare att testa dem. Speciellt eftersom de modifierade "protected/private" attribut. Dessa blev lite svårare att testa, min lösning var att
        ändra om metoderna så att attributen returnerades när metoderna kallades.
         Jag hade även ett par situationer med if-satser som hade flera olika elseif-förgreningar. Det kändes till en början omständligt att testa dem men jag la till en del mock objects som gjorde att jag lyckades ändå. 
    </p>

    <p class="report">Vissa av mina metoder returnerade inget (de räknade bara ut värder på ett protected/privat attribut), vilket gjorde det svårt att testa dem med assertEqual. Därför såg jag till att de returnerade attributet,
        jag räknade manuellt sen ut vad det attributet borde vara och använde det för att testa metoderna.<br>
        Jag använde mig en del av dependency injection när jag designade mina klasser, jag utnyttjade mockobjekt för att göra det enklare att testa dem. Det fanns dock vissa tillfällen då jag 
        undrade om mitt test verkligen testade metoden eller om det bara testade att mockobjektet var rätt inställt.
    </p>

    <p class="report">"Testbar" kod i sig lämnar nog en del kod att greppa tag i som skulle kunna vara "överflödig", jag tänker exempelvis på mina metoder som nämndes ovan som endast ändrade om attribut men nu var tvungna att även
        returnera attributen för att kunna vara testbara. 
        Jag tror däremot också att det tvingar en att vara ännu mer strukturerad och ha kod som är enklare att granska. Detta innebär alltså passande variabelnamn, 
        färre genvägar som gör koden svår att läsa, välplacerade kommentarer samt att man inte har onödiga conditional statements som är svåra att täcka in under testerna. 
        Detta, tillsammans med testerna, gör det lättare att sätta sig in i koden.
    </p>

    <p class="report">Mina TIL för detta KMOM är följande</p>
    <ul class="ul-report">
        <li>Det finns verktyg som hjälper en att skapa överskådlig dokumentation utifrån sina DocBlocks.</li>
        <li>Det finns verktyg som förenklar testandet av koden samt hjälper en att se till så att man testar alla delar av sin kod.</li>
        <li>Man bör kolla på mer än bara kodtäckningen när man designar ett test, det är lätt att lura sig att ett test gör något som det inte gör.</li>
        <li>Jag lärde mig att man kan använda sig av "reflection" för att få reda på mer om en klass (exempelvis protected/privata fält).</li>
        <li>Jag lärde mig att man behöver inte alltid testa sina getter/setter-metoder.</li>
    </ul>

<h1 id="kmom05">Kmom05</h1></a>

<p class="report">Övningen med Symfony och Doctrine gick bra. Jag copy/pasteade bara i princip. Det jobbiga för mig var framförallt att förstå migrations-delen och att 
    förstå processen bakom när man skulle använda *Repository och ManagerRegistry. Jag har nog inte fattat det helt än men jag tror att det lossnar när man arbetar mer med det. Jag har stött på lite
    ORM innan så jag är inte helt ovan. Men ibland tänker jag att det är enklare att arbeta via PHP PDO eller liknande direkt.
</p>

<p class="report">
    Jag insåg ganska snabbt att uppgiften inte var så utmanande ifall man bara följde kraven. Vi har ju gjort liknande CRUD-uppgifter 2-3 gånger innan.
    Därför ville jag göra det lite mer avancerat. Jag bestämde mig för att använda Symfonys inbyggda formulärshanterare samt filuppladdning.
    Jag följde några tutorials för att få dem att fungera. Men just formulär+filuppladdnings-delen tog säkert 50% av tiden med det här kursmomentet.<br>
    Jag stal en del av gränssnittet från Webapp-kursen. Jag hade ingen plan angående utseendet till en början men insåg att det passade bra att göra den smal och mobilvänlig.
</p>
<p class="report">Det gick ganska bra att arbeta med ORM, jag såg inga egentliga problem med den biten.
    Man kan antingen skapa queries där man arbetar med objekten enligt repository data pattern eller så kan man använda sig av
    rå SQL (vilket jag gjorde i library/reset). Även om det var relativt rättframt hur man arbetar med ORM så är jag inte helt säker på vad som är best practice.
</p>

<p class="report">Min uppfattning om ORM är att jag kan se varför det behövs men jag tror att det hittills bara har förenklat vårt kodande marginellt. Det blir säkert väldigt användbart
    ju mer man arbetar mot databaserna och ju mer komplicerad ens applikation blir. En fördel är att man behöver knappt kunna någon SQL för att använda dem och 
    syntaxen/koduppbyggnaden följer resten av applikationen.<br>Tidigare har vi jobbat med PHP PDO som är överskådligt och intuitivt. Nackdelen är att man själv får koppla svaren från databasen till sina objekt och klasser.
    Man får också nästan utföra en ritual för att koppla upp sig mot databasen.
</p>

<p class="report">Jag har ett par TIL:</p>
<ul class="ul-report">
    <li>Det finns inbyggd formulärshantering i Symfony.</li>
    <li>Man kan förenkla sitt arbete mot en databas med en ORM, Doctrine fungerar bra med Symfony.</li>
    <li>Om man vill kunna ladda upp en fil på dbwebb via browsern så bör man döpa tillhörande mapp till storage, db, var, cache, web/assets.</li>
    <li>Man kan spara filer i databasen via blob-filtypen.</li>
    <li>Symfony med Doctrine använder sig av Repository Design Pattern. Det finns många design patterns för att koppla en databas mot en applikation.</li>
</ul>

<h1 id="kmom06">Kmom06</h1></a>

<p class="report">Phpmetrics var väldigt överskådligt och lättnavigerat. Jag la fokus på de delarna som jag tyckte, intuitivt, var enkla att förstå (speciellt komplexitet). Det fanns en del värden
    som jag inte kände att jag förstår. Även om jag hade förstått dem så tänkte jag att min kod har ju fungerat hittills, vad bryr jag mig om detta? Visserligen så ska
    det göra min kod mer robust men jag har inte tänkt att det behövs. Jag ser ändå att ifall jag skulle bygga vidare på koden då skulle Phpmetrics komma mer till användning.
</p>
<p class="report">Det tog mig 5-6 timmar att få Scrutinizer att fungera, jag hade dessa hinder: fel PHP-version, 
    min .env-fil laddades inte upp till mitt git-repo på grund av att jag hade den i .gitignore och en av mina Sass-moduler som jag hade installerat fungerade inte på Scrutinizer. När jag väl började skapa tester
    så fick jag fel i de Controller-tester som skulle kontrollera att man fick en respons från routen. Jag var därför tvungen att göra om dessa. Här var det återigen coverage men också
    issues jag var mest fokuserad på. <br>Jag fick 9.97 på code rating när jag laddade upp min kod, då tänkte jag att Scrutinizer inte var till särskilt stor nytta. Jag arbetade ändå för att få upp 
        ratingen till 10. I början hade jag en kodtäckning på 26% (röd kategori) men jag arbetade upp den till 54% (gul kategori).
    </b>

</p>
<p class="report">Jag tror att man bör bestämma sig för en viss nivå på kodkvalitet från början utifrån vad man vill åstadkomma. Ju snabbare och kreativ man vill vara,
    desto mindre fokus bör man lägga på "clean code". Vill man ha ett robust program som ska serva en stor mängd människor eller samhällsviktiga funktioner så bör man ha högre standard på sin kodkvalitet.
    Vill man även framtidssäkra sin kod så bör man tänka på kodkvaliteten. Jag tror att badges är ett riktmärkte för dem som verkligen bryr sig om kodkvalitet och struktur, jag tror också att de berättar om hur mycket tid
    man lägger på ny kod jämfört med att förvalta befintlig kod.
</p>

<p class="report">Jag har ett par TIL för detta kmom</p>
<ul class="ul-report">
    <li>Scrutinizer och Phpmetrics är två verktyg man kan integrera i sin kod för att säkerställa att man håller en hög kodkvalitet. Detta är något man gör utöver lintingen.</li>
    <li>Det finns väldigt många olika mätvärden och KPI:er för vad som kännetecknar kodkvalitet.</li>
    <li>Testning är allmänt känt för att öka kodkvalitet.</li>
    <li>Cyklomatisk komplexitet är något man bör hålla nere.</li>
</ul>

<h1 id="kmom10">Kmom10</h1></a>

<h2>Krav 1-3: Webbplats</h2>
<p class="report">Jag valde att skapa ett point-and-click-spel i form av en escape room, med 4-6 banor (beroende på hur man räkna).
    Tanken är att man ska ta sig till sista rummet och klara spelet. Man kan klicka var som helst på en bild och se ifall det leder till någon specifik reaktion.
    Spelet är skapat i 8-bitarsgrafik. Jag har använt mig av ChatGPT för att ta fram bilder. Promptsen till ChatGPT har varit någon variant av ”8-bit images of medieval style cottage",
    ”sling”, ”portals”, ”hatch” med mera. Jag har modifierat promptsen för att se till så att jag får bilden såsom jag vill ha den (can you make the portal key look like a
    garage opener but in 8 bit-style but more in tune with the previous image?).</p>

<p class="report">Jag skapade en ny SCSS-mapp för att bygga den nya stylesheet:en. Återanvände tidigare SCSS-filer men såg till så att fonten var mer lik spelet,
    jag la till bakgrundsbild, tog bort footer, la till 8-bitsknappar (inte min egen CSS-kod, jag hittade den på nätet), alltså allt för att göra sidan mer likt ett 8-bitarsspel.
    Spelet är inte anpassat för att vara mobilt responsiv, det hade nog gjort kodningen mycket mer komplicerad. </p>

<p class="report">Min README.md var skapad i kmom01/02 men hade en bra grundstruktur som jag ändrade om i och anpassade för kmom10.
    Jag la till en extra bild och beskrev kursen, kursmomenten och projektet.</p>

<p class="report">Mina badges från Scrutinizer var kvar från tidigare kmom.</p>

<p class="report">Jag testade alla klasser som jag själv hade skrivit för att få en kodtäckning på nästan 100% (även controllers). 
    Detta innebär alltså att jag knappt testade Repository och all testning av Entities var en biprodukt, allt annat som inte testades exkluderades från coverage rapporten.</p>
<h2>Krav 4: JSON</h2>
<p class="report">Det svåra med detta krav var inte den tekniska biten. Det var att fundera ut 5 olika API-routes som var användbara för mitt projekt. Till slut så landade jag på dessa routes:</p>
<ul class="report">
<li>En lista på alla som nådde det lyckliga slutet i spelet.</li>
<li>En lista på alla som nådde det olyckliga slutet i spelet.</li>
<li>Få status på spelet (den kollar diverse sessionvariabler).</li>
<li>IP-adresser på alla som har valt att spara sitt namn när man har klarat spelet.</li>
<li>Återställ alla tabeller till defaultläge.</li>
<li>POST: man flyttar alla namn i tabellen för det olyckliga slutet till det lyckliga slutet. De går från condemned till saved alltså. För att POST action ska fungera så har jag kopplat denna knapp till ett formulär</li>
</ul>

<p class="report">Alla routes, förutom en, var kopplade till databasen. Jag skapade en egen APIProjController-klass för att göra koden lite mer överskådlig och objektorienterad. Jag skapade även tester för alla routes i controllern.</p>
<p class="report">Alla länkar gjordes i 8-bitars knappar för att de skulle vara enhetliga med resterande projekt.</p>
<h2>Krav 5: ORM</h2>

<p class="report">Jag skapade tre Entities med tillhörande Repositories (och tillhörande tabeller) via Doctrine. 
Jag använde mig av SQLite här för att jag anser det vara en enkel lösning till en enkel liten databas som inte kräver en server. 
Jag hade två tabeller för att spara alla som fullföljde spelet och en tabell för att spara IP-adresserna på de som klarade spelet. 
Dessa tabeller är inte direkt kopplade till varandra, de hade kunnat vara det, men jag bestämde mig för att ha en lös koppling istället. 
Detta innebär att jag har funktioner som för in lite av informationen i de två andra tabellerna till IP-tabellen. 
När man raderar någon rad i de två andra tabellerna så påverkas inte IP-tabellen. Det finns också en funktion som för över alla rader i ena tabellen till den andra tabellen.</p>

<p class="report">Informationen i tabellerna får man tillgång via API-routes:en som skapades i krav 4.</p>

<p class="report">Jag gjorde några enkla enhetstester till Repository-klasserna bara för att testa om det fungerade, 
jag gjorde dock aldrig några till Entity för att det kändes mer tidskrävande än tankemässigt utmanande.</p> 

<p class="report">Mitt ER-diagram gjordes med draw.io.</p>
<h2>Krav 6: Avancerade features</h2>
<p class="report">Jag skulle vilja framhäva följande features:</p>
<ol class="ul-report">
<li><p class="report">100% kodtäckning på mina levels i point-and-click-spelet samt 100% kodtäckning i mina två controller-klasser till det här projektet. 
    En stor del av controllers är beroende av formulärdata och sessions. Jag arbetade länge med att försöka ”mocka” sessiondata och formulärdata. 
    Formulärdatan var tvungen att hanteras på två sätt beroende på ifall jag använde Symfonys inbyggda formulärklass (FormBuilderInterface) eller ifall jag använde ett vanligt HTML-formulär.</p> 

    <p class="report">Formulärtestningen löste jag genom att lägga till parametrar i $client->request()-funktionen (mer om $client senare) 
        med datan som jag ville skicka samt en header som säkerställde att content-type var "application/x-www-form-urlencoded". 
        Jag använde den inbyggda DOM-crawlern i Symfony för att testa FormBuilderInterface-formuläret.</p>
    
    <p class="report">Det var betydligt svårare att testa routes som var beroende av session. Mina mock sessions och cookies fungerade inte. 
        Jag fick inte session-variablerna som jag skapade i testfunktionen att följa med in i route-funktionen. 
        Till slut insåg jag att $client som jag använt för att skapa requests mot mina routes i testklasserna är en typ av headless browser. 
        Den fungerar alltså som en browser utan GUI. För att få in data i session så får man dirigera den till att utföra de handlingar på sidan som skapar den data jag vill ha. 
        Om mitt spel exempelvis ställer om variabeln key=false till key=true efter att man klickar på en viss punkt på en av banorna i mitt spel, 
        då får man se till så att $client utför denna klickning också. Efter denna insikt kunde jag få upp min kodtäckning till 100%.</p>
    
    <p class="report">Man kan diskutera ifall testandet skedde på rätt sätt och ifall kodtäckning är det bästa mätvärdet för att bedöma ifall koden har rätt tester. 
        Dock anser jag det ändå vara en bedrift att lyckas få 100% kodtäckning och mina tester ger en bra bild av ifall applikationen fungerar som den ska.</p>
    </li>
<li>

    <p class="report">Min abstrakta klass Level samt mina alla "levels" byggda på denna. 
    För att göra det enklare för mig att lägga till nya banor/levels i mitt spel så skapade jag en grundläggande abstrakt klass: 
    Level. Denna innehöll abstrakta och konkreta metoder som alla ärvande klasser kunde skapa och modifiera. 
    Den grundläggande idén var att varje klass ska ha metoder som berättar:</p>
    <ul class="ul-report">
    <li>var man ska kunna klicka för att spelet ska reagera (antingen att man klickar vidare till nästa bana eller att man får en nyckel eller item).</li>
    <li>vilken bild spelet ska baseras på.</li>
    <li>vilken nästa bana är och vad kravet är för att få tillgång till den banan. Man kan ställa in egen logik för varje bana eller utgå från den abstrakta klassens logik.</li>
    <li>vilken föregående bana var.</li>
    <li>samt har enkla metoder för att hämta ut data.</li>
    </ul>
    <p class="report">Detta tycker jag är en elegant objektorienterad lösning för att bygga mitt spel på ett enkelt och enhetligt sätt. 
        Skulle jag vilja så hade det varit enkelt att skapa fler levels.</p>
</li>

<li>
<p class="report">Min klick-funktion i spelet som baseras på att jag bland annat ändrade importmap.php och webpack.config.js för att importera en proj.js-fil. 
    Denna proj.js-fil användes istället för den vanliga app.js, vars syfte är att importera .scss-filer.</p>

    <p class="report">I proj.js skapade jag en event listener som spårade koordinaterna på varje klick i spelet. 
        Den la sen in dessa koordinater som värden i ett dolt formulär och submittade det formuläret. 
        Jag hade en route som kontrollerade ifall klick-koordinaterna hamnade i närheten av någon dörr/item på den specifika banan. 
        Om den gjorde det så sparades detta item, eller så kunde man kontrollera ifall man hade alla rätt items (nycklar) för att gå vidare till nästa level. 
        Som tidigare nämnt så kunde man för varje level ställa in var de dolda objekten/dörrarna skulle ligga och vad som krävdes för att man skulle få tillgång till nästa level.</p>
    
    <p class="report">Denna enkla lösning med en event listener och ett dolt formulär tycker jag är minimalistiskt och lätt att förstå. 
        Den är robust och går inte alltför långt utanför kursens PHP-ramar, JavaScript-koden är endast på 8 rader.</p>
</li>
<li>
<p class="report">Jag är också nöjd med dessa saker som är lite enklare men utanför kursens ramar:</p>
<ul class="ul-report">
    <li>Ett enhetligt 8-bitars gränssnitt som förstärks av mina ChatGPT-genererade-bilder. 
    För 40 år sen så hade man kanske kunnat tjäna mycket pengar på ett spel som detta, fast litet större.</li>
    <li>Jag använder Symfonys egna inbyggda FormBuilderInterface för att skapa ett formulär som sparar namnet på de som slutför spelet. 
    Jag är nöjd med denna bit för att vi inte har gått igenom detta i kursen tidigare, det är trevligt att kunna skapa en lösning utifrån Symfony-dokumentation 
    istället för dokumentation från kursen.</li>
</ul>
</li>
</ol>

<h2>Om projektets genomförande</h2>
<p class="report">Projektet tog mer än de där 20-40 timmarna. Förutom spellogiken och grafiken, som jag beskrev i krav 6 ovan, så tog testningen och Scrutinizer-delen lång tid (jag tror jag la 8-10h på felsökande). 95% av alla mina Scrutinizer-fel berodde på att min .gitignore-fil ledde till att relevanta delar inte laddades upp till mitt repo. Nu tror jag mig i alla fall veta hur man använder Scrutinizer och feltestar på ett mindre smärtsamt sätt.</p>
<p class="report">Jag förstår också att när man gör något så fritt som ett spel som man designar själv så kan det leda till att det tar mycket längre tid, projektet har ju färre ramar att förhålla sig till. Jag är ändå nöjd med mitt val och jag tror inte jag hade klarat av att programmera ytterligare ett kortspel. Detta var betydligt mer stimulerande.</p>
<p class="report">I övrigt så kunde man återanvända mycket av koden från tidigare kursmoment. Vi hade ju redan byggt upp produktionsmiljön sen innan. Vi hade också blivit bekanta med alla verktyg (PHPUnit, PHPMD etc.). </p>
<p class="report">Jag blev lite förvirrad kring ORM-kravet, eller specifikt ER-diagrammet. Jag fick känslan av att man skulle skapa flera foreign keys och relationer i ens databas. Jag gjorde inte detta för jag kände inte att det behövdes och det fanns inget specifikt krav, men jag fick känslan att man hintade till att man bör göra det. </p>
<p class="report">Projektet var kanske fortfarande lite för stort för kursen, jag hade gärna haft det lite mindre omfattande. I såna fall hade man kanske kunnat skära ner på Scrutinizer-delen.</p>
<h2>Tankar kring kurs</h2></p>
<p class="report">Jag är återigen väldigt nöjd med ytterligare en av era kurser! Vi täckte många områden, jag gillar detta. Vi arbetade enligt MVC-mönstret, vi lärde oss mer om OOP, vi byggde vidare på våra databaskunskaper, vi lärde oss att arbeta med Symfony, vi utförde fler enhetstester m.m. </p>
<p class="report">Vi kollade överskådligt på en del designmönster och vad bra kod är, vilket var väldigt intressant. Jag hade gärna grottat ner mig mer i den senare delen.</p>
<p class="report">Hade jag rekommenderat kursen till kollegor? Absolut, speciellt om det handlar om att utveckla webbapplikationer i något PHP-ramverk. </p>
<p class="report">Två förbättringsområden: skulle ni kunna berätta mer om felsökande i Scrutinizer (alt. skrota Scrutinizer helt)? Det börjar bli lite tråkigt med alla enkla kortspel, tärningar osv. hade ni eventuellt skapa lite andra utmaningar?</p>
<p class="report">Hur som helst så är jag nöjd med kursen, jag tycker jag har lärt mig mycket matigt. Jag känner mig redo att testa att bygga en egen fri applikation i Symfony/Laravel till sommaren. Jag ger kursen 8.5/10.</p>


</div>

{% endblock %}